#include <msp430.h>
#include <msp430fr6989.h>
#include <stdint.h>
#include <stdbool.h>

#define F_CPU_HZ        8000000UL   // 8 MHz DCO
#define PWM_FREQ_HZ     19000UL     // ~20 kHz PWM
#define SYSTICK_HZ      1000UL      // 1 kHz control update
#define PWM_TICKS       (F_CPU_HZ / PWM_FREQ_HZ)

// Joystick channels (A7, A8 = P8.4, P8.5)
#define JOY_X_CH        ADC12INCH_7
#define JOY_Y_CH        ADC12INCH_8

#define JOY_DEADZONE_PCT 8          // wider deadzone helps jitter
#define MIX_TURN_GAIN    1.0f
#define MIN_RUN_PCT      5          // below this, force 0% duty

// --- L298 pins ---
#define IN1_PORT P1OUT
#define IN1_DIR  P1DIR
#define IN1_BIT  BIT3

#define IN2_PORT P3OUT
#define IN2_DIR  P3DIR
#define IN2_BIT  BIT0

#define IN3_PORT P3OUT
#define IN3_DIR  P3DIR
#define IN3_BIT  BIT1

#define IN4_PORT P2OUT
#define IN4_DIR  P2DIR
#define IN4_BIT  BIT3

// Globals for PWM duty (start at 0)
static volatile uint16_t dutyA = 0;
static volatile uint16_t dutyB = 0;

// Joystick centers measured at boot
static uint16_t joy_x_center = 2048;
static uint16_t joy_y_center = 2048;

// ================== Basic hardware init ==================
static void clock_init_8MHz(void) {
    CSCTL0_H = CSKEY_H;
    CSCTL1 = DCOFSEL_6;  // 8 MHz
    CSCTL2 = SELM__DCOCLK | SELS__DCOCLK | SELA__VLOCLK;
    CSCTL3 = DIVM__1 | DIVS__1 | DIVA__1;
    CSCTL0_H = 0;
}

static void gpio_init(void) {
    // LED (heartbeat)
    P1DIR |= BIT0; P1OUT &= ~BIT0;

    // L298 direction pins
    IN1_DIR |= IN1_BIT; IN1_PORT &= ~IN1_BIT;
    IN2_DIR |= IN2_BIT; IN2_PORT &= ~IN2_BIT;
    IN3_DIR |= IN3_BIT; IN3_PORT &= ~IN3_BIT;
    IN4_DIR |= IN4_BIT; IN4_PORT &= ~IN4_BIT;

    // PWM pins: P3.3=TA1.1, P3.6=TB0.2
    P3DIR  |= (BIT3 | BIT6);
    P3SEL1 |= (BIT3 | BIT6);
    P3SEL0 &= ~(BIT3 | BIT6);

    // Joystick analog: P8.4=A7, P8.5=A8
    P8SEL0 |= (BIT4 | BIT5);
    P8SEL1 &= ~(BIT4 | BIT5);
}

static void timer_pwm_init(void) {
    TA1CCR0 = PWM_TICKS - 1;
    TA1CCR1 = 0;
    TA1CCTL1 = OUTMOD_7;
    TA1CTL = TASSEL__SMCLK | MC__UP | TACLR;

    TB0CCR0 = PWM_TICKS - 1;
    TB0CCR2 = 0;
    TB0CCTL2 = OUTMOD_7;
    TB0CTL = TBSSEL__SMCLK | MC__UP | TBCLR;
}

static void timer_systick_init(void) {
    TA0CCR0 = (F_CPU_HZ / SYSTICK_HZ) - 1;
    TA0CCTL0 = CCIE;
    TA0CTL = TASSEL__SMCLK | MC__UP | TACLR;
}

static void adc12_init(void) {
    ADC12CTL0 = ADC12SHT0_2 | ADC12ON;
    ADC12CTL1 = ADC12SHP;
    ADC12CTL2 = ADC12RES_2; // 12-bit
}

// ================== Helpers ==================
static uint16_t adc12_read(uint8_t channel) {
    ADC12CTL0 &= ~ADC12ENC;
    ADC12MCTL0 = channel;
    ADC12CTL0 |= ADC12ENC | ADC12SC;
    while (ADC12CTL1 & ADC12BUSY);
    return ADC12MEM0;
}

static void joystick_calibrate_centers(void) {
    // sample for ~100ms (100 samples @ 1kHz-ish loop here)
    uint32_t sx = 0, sy = 0;
    for (int i = 0; i < 128; i++) {
        sx += adc12_read(JOY_X_CH);
        sy += adc12_read(JOY_Y_CH);
        __delay_cycles(8000 * 1); // ~1 ms at 8 MHz
    }
    joy_x_center = (uint16_t)(sx / 128);
    joy_y_center = (uint16_t)(sy / 128);
}

static int16_t map_to_pct(uint16_t adc, uint16_t center) {
    int32_t centered = (int32_t)adc - (int32_t)center;
    int32_t pct = (centered * 100) / 2048;    // assume ~3.3V full-scale
    if (pct > 100) pct = 100;
    if (pct < -100) pct = -100;
    if (pct > -JOY_DEADZONE_PCT && pct < JOY_DEADZONE_PCT) pct = 0;
    return (int16_t)pct;
}

// Motor direction helpers
static inline void dir_A_forward(void){ IN1_PORT |= IN1_BIT; IN2_PORT &= ~IN2_BIT; }
static inline void dir_A_reverse(void){ IN1_PORT &= ~IN1_BIT; IN2_PORT |=  IN2_BIT; }
static inline void dir_B_forward(void){ IN3_PORT |= IN3_BIT; IN4_PORT &= ~IN4_BIT; }
static inline void dir_B_reverse(void){ IN3_PORT &= ~IN3_BIT; IN4_PORT |=  IN4_BIT; }

static void set_speed_A_percent(uint8_t pct) {
    if (pct < MIN_RUN_PCT) pct = 0;
    if (pct > 100) pct = 100;
    dutyA = (uint16_t)((uint32_t)PWM_TICKS * pct / 100U);
    TA1CCR1 = dutyA;
    if (pct == 0) { // optional: ensure coast by dropping both inputs low
        IN1_PORT &= ~IN1_BIT;
        IN2_PORT &= ~IN2_BIT;
    }
}
static void set_speed_B_percent(uint8_t pct) {
    if (pct < MIN_RUN_PCT) pct = 0;
    if (pct > 100) pct = 100;
    dutyB = (uint16_t)((uint32_t)PWM_TICKS * pct / 100U);
    TB0CCR2 = dutyB;
    if (pct == 0) {
        IN3_PORT &= ~IN3_BIT;
        IN4_PORT &= ~IN4_BIT;
    }
}

static void motorA_signed(int16_t pct){
    if (pct > 0)      { dir_A_forward(); set_speed_A_percent((uint8_t)pct); }
    else if (pct < 0) { dir_A_reverse(); set_speed_A_percent((uint8_t)(-pct)); }
    else              { set_speed_A_percent(0); }
}
static void motorB_signed(int16_t pct){
    if (pct > 0)      { dir_B_forward(); set_speed_B_percent((uint8_t)pct); }
    else if (pct < 0) { dir_B_reverse(); set_speed_B_percent((uint8_t)(-pct)); }
    else              { set_speed_B_percent(0); }
}

// ================== Joystick processing ==================
static void joystick_step(void) {
    uint16_t x_raw = adc12_read(JOY_X_CH);
    uint16_t y_raw = adc12_read(JOY_Y_CH);

    int16_t x = map_to_pct(x_raw, joy_x_center);
    int16_t y = map_to_pct(y_raw, joy_y_center);

    float k = MIX_TURN_GAIN;
    float left_f  = (float)y - k * (float)x;
    float right_f = (float)y + k * (float)x;

    if (left_f  > 100) left_f  = 100;
    if (left_f  < -100) left_f = -100;
    if (right_f > 100) right_f = 100;
    if (right_f < -100) right_f = -100;

    motorA_signed((int16_t)left_f);
    motorB_signed((int16_t)right_f);
}

// ================== main ==================
int main(void) {
    WDTCTL = WDTPW | WDTHOLD;
    PM5CTL0 &= ~LOCKLPM5;

    clock_init_8MHz();
    gpio_init();
    adc12_init();

    // IMPORTANT: center the joystick and don't touch it for ~0.1 s
    joystick_calibrate_centers();

    timer_pwm_init();
    timer_systick_init();

    __enable_interrupt();

    while (1) {
        __bis_SR_register(LPM0_bits | GIE);
        __no_operation();
    }
}

// ================== 1 kHz control ISR ==================
void __attribute__((interrupt(TIMER0_A0_VECTOR))) TIMER0_A0_ISR(void) {
    joystick_step();

    static uint16_t hb = 0;
    if (++hb >= 250) { hb = 0; P1OUT ^= BIT0; } // blink LED
    __bic_SR_register_on_exit(LPM0_bits);
}
